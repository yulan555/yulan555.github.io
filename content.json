{"pages":[],"posts":[{"title":"Hello World","text":"欢迎来到Hexo！这是一个很棒的文章。检查文档为了获取更多的信息。如果你有很多的问题当你使用Hexo，你能找到很多答案在问题解答或你能向我提问在GitHub。 快速开始创建一个新页面1$ hexo new &quot;My New Post&quot; 更多信息： Writing 运行服务1$ hexo server 更多信息： Server 生成静态文件1$ hexo generate 更多信息： Generating 部署到站点1$ hexo deploy 更多信息： Deployment","link":"/2020/12/27/hello-world/"},{"title":"八皇后思路与解法","text":"这是一个关于我自己对于八皇后问题的看法，当然结合了很多网上的思路。 问题分析先从这个说起吧，先分析一下问题，就是有一个$8\\times8$的一个棋盘，要往其中放8个皇后棋子，使各个皇后棋子不能互相攻击到。 皇后的攻击范围是他的横向、纵向和斜向，这几个方向 ↖ ↑ ↖ ↑ ↗ ← ← ○ → ↙ ↓ ↘ 就比如这个皇后攻击范围图，所以我们要通过搜索和回溯来进行判断。 具体做法用到的头文件 1#include &lt;iostream&gt; 定义一个皇后的结构体 1234struct Queen{ int x; int y;}q[16];//皇后结构体，存皇后位置,先声明了一个结构体数组q[16] 因为皇后能攻击到横向的所以敌人，所以每行我们只用放一个皇后就OK了，横向的问题解决了，接下来纵向和斜向的问题，我采用的是纵向循环一遍这个皇后放置的位置，判断是否能被其他皇后纵向和斜向攻击到。 12345678910111213141516171819202122232425for(y=0;y&lt;n;y++){//循环皇后纵向位置，i为第几个皇后，i-1是皇后的横向位置，n为共有几个皇后 f=true; if(i==1){ q[i-1].x=i-1; q[i-1].y=y; HuangHou(n,i+1); continue; } for(m=0;m&lt;i-1;m++){//遍历已经存入的皇后位置 if(q[m].y==y){//判断能否被纵向攻击 f=false; break; } if(q[m].x-q[m].y==i-1-y||q[m].x+q[m].y==i-1+y){//判断能否被斜向攻击 f=false; break; } } if(f){ q[i-1].x=i-1; q[i-1].y=y; //存入第i个皇后位置 HuangHou(n,i+1);//递归下一个皇后位置 }} $q[m].x-q[m].y==i-1-y$为右斜方向皇后攻击能否被攻击到 ○ ↘ ↘ ↘ $q[m].x+q[m].y==i-1+y$为左斜方向皇后攻击能否被攻击到 ○ ↙ ↙ ↙ 之后不断递归直到当前将放的皇后数大于需要放置的皇后数 1234567if(i&gt;n){ sum++;//答案总和加一 for(m=0;m&lt;n;m++){ cout&lt;&lt;&quot;(&quot;&lt;&lt;q[m].x&lt;&lt;&quot;,&quot;&lt;&lt;q[m].y&lt;&lt;&quot;)&quot;;//输出答案 } cout&lt;&lt;endl;} 详细代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;using namespace std;struct Queen{ int x; int y;}q[16];//皇后结构体，存皇后位置 bool f=false;//指示是否弄插入皇后 int sum=0;//答案总和 void HuangHou(int n,int i){ int m,y; f=true; if(i&gt;n){ sum++;//答案总和加一 for(m=0;m&lt;n;m++){ cout&lt;&lt;&quot;(&quot;&lt;&lt;q[m].x&lt;&lt;&quot;,&quot;&lt;&lt;q[m].y&lt;&lt;&quot;)&quot;;//输出答案 } cout&lt;&lt;endl; } for(y=0;y&lt;n;y++){//循环皇后纵向位置，i为第几个皇后，i-1是皇后的横向位置 f=true; if(i==1){ q[i-1].x=i-1; q[i-1].y=y; HuangHou(n,i+1); continue; } for(m=0;m&lt;i-1;m++){//遍历已经存入的皇后位置 if(q[m].y==y){//判断能否被纵向攻击 f=false; break; } if(q[m].x-q[m].y==i-1-y||q[m].x+q[m].y==i-1+y){//判断能否被斜向攻击 f=false; break; } } if(f){ q[i-1].x=i-1; q[i-1].y=y; //存入第i个皇后位置 HuangHou(n,i+1);//递归下一个皇后位置 } }}int main(){ int n; cin&gt;&gt;n;//输入几个皇后 HuangHou(n,1); cout&lt;&lt;sum&lt;&lt;endl;} 感觉自己思路很混乱不过也算写了出来，就这样过吧。","link":"/2021/01/01/%E5%85%AB%E7%9A%87%E5%90%8E%E6%80%9D%E8%B7%AF%E4%B8%8E%E8%A7%A3%E6%B3%95/"}],"tags":[{"name":"-学习记录 -算法","slug":"学习记录-算法","link":"/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"Hexo","slug":"Web/Hexo","link":"/categories/Web/Hexo/"},{"name":"-学习 -C++ -算法","slug":"学习-C-算法","link":"/categories/%E5%AD%A6%E4%B9%A0-C-%E7%AE%97%E6%B3%95/"}]}